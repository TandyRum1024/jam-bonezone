<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup resolution
winSizeW = 1024;
winSizeH = 768;
camResW = winSizeW &gt;&gt; 2;
camResH = winSizeH &gt;&gt; 2;

gameSurf = surface_create(camResW, camResH);
window_set_size(winSizeW, winSizeH);
application_surface_enable(false);

view_wview[0] = camResW;
view_hview[0] = camResH;
view_wport[0] = winSizeW;
view_hport[0] = winSizeH;
view_surface_id[0] = gameSurf;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup 3D
z3d_init();

playerHeight = 12;
playerHeightBase = 12;

// camera attributes
camFov = 90;
camNear = 1;
camFar = 512;

// camera bob
camZ = playerHeight;
camBobCounter = 0;
camBobAmp = 4;

// keyboardlook related
camLookVel = 1;
camLookVelMax = 4;
camVelRot = 0;
camVelTilt = 0;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertex buffer setup

// format
vertex_format_begin();
vertex_format_add_position_3d();
vertex_format_add_textcoord();
vertex_format_add_colour();
lvlVF = vertex_format_end();

// lut for vertex weaving
_lutx = -1;
_lutx[0] = 0;
_lutx[1] = 1;
_lutx[2] = 0;
_lutx[3] = 0;
_lutx[4] = 1;
_lutx[5] = 1;
_luty = -1;
_luty[0] = 0;
_luty[1] = 0;
_luty[2] = 1;
_luty[3] = 1;
_luty[4] = 0;
_luty[5] = 1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Prepare billboard / floor VB
// billboard focus point
global.billboardFocusX = camX;
global.billboardFocusY = camY;

// pre-build floor vertex buffer
global.floorVB = vertex_create_buffer();
vertex_begin(global.floorVB, lvlVF);

var _subdiv = 4;
var _divunit = 1 / _subdiv;
for (var i=0; i&lt;_subdiv; i++)
{
    for (var j=0; j&lt;_subdiv; j++)
    {
        for (var c=0; c&lt;6; c++)
        {
            var _vx = (i + _lutx[c]) * _divunit, _vy = (j + _luty[c]) * _divunit;
            
            vertex_position_3d(global.floorVB, -0.5 + _vx, -0.5 + _vy, 0);
            vertex_texcoord(global.floorVB, _vx, _vy);
            vertex_colour(global.floorVB, c_white, 1.0);
        }
    }
}

vertex_end(global.floorVB);
vertex_freeze(global.floorVB);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Game variables
enum gSTATE
{
    PRE = 0,
    MOVE,
    DIALOGUE,
    ITEM_GET,
    PAUSED,
    END
}

state = gSTATE.PRE;
stateInit = false;
stateTime = 0;

/// state dependant vars
dialogueTransitionCtr = 0;
dialogueIn = true;

itemTransitionCtr = 0;
itemIn = true;

itemTarget = noone;
itemName = "DEF";
itemDesc = "WHAT?";
itemSprite = sprItem;
itemIdx = 0;

trashLeft = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Map init &amp; build texture atlas
d3d_end();

// attributes
global.gridSize = 128;
gridSizeHalf = global.gridSize &gt;&gt; 1;
gridW = 16;
gridH = 16;

// vertex buffer to draw
mapVB = ds_grid_create(gridW, gridH);

// seed
global.seed = string(current_time);
global.seedval = abs(sin(makeHash(global.seed) * 35.0)) * 420.0;

// prepare texture
var _texW = 32, _texH = 32;
var _textures = -1;
_textures[0] = texFence;
_textures[1] = texFloor1;
_textures[2] = texFloor2;
_textures[3] = texFloor3;

var _surf = surface_create(_texW * array_length_1d(_textures), _texH);

// blit all textures into one huge surface
surface_set_target(_surf);
draw_clear_alpha(0,0);
for (var i=0; i&lt;array_length_1d(_textures); i++)
{
    draw_sprite(_textures[@ i], 0, i * _texW, 0);
}
surface_reset_target();

global.mapTexSpr = sprite_create_from_surface(_surf, 0, 0, surface_get_width(_surf), surface_get_height(_surf), false, false, 0, 0);
global.mapTex = sprite_get_texture(global.mapTexSpr, 0);
global.mapTexUnit = _texW / surface_get_width(_surf);
surface_free(_surf);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize player variables
// Properties
gridX = floor(camX / global.gridSize);
gridY = floor(camY / global.gridSize);
velFwd = 0;

footstepPlayed = false;
footstepIdx = 1;

// Dialogue?
quipStr = "";
listenCtr = 0;
listenCtrMax = room_speed;

canQuip = false;
showQuip = false;
quipDist = 32;
quipTarget = noone;

// Item focus
itemDist = 16;
itemTarget = noone;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player hands
// universal hand variables
handSize = 20;
handMargin = 24;
handFwd = 30;
handZ = -20;

// separate hand variables
hand1RotX = 0;
hand2RotX = 0;
hand1Flip = 0;
hand2Flip = 0;

hand1Fwd = 0;
hand2Fwd = 0;
hand1Side = 0;
hand2Side = 0;
hand1Z = 0;
hand2Z = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Generate map
generate_map(global.seedval);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Place player in random position
camX = 0;//random_range(8, gridW * gridSize - 8);
camY = 0;//random_range(8, gridH * gridSize - 8);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Begin 3D
d3d_start();
d3d_set_zwriteenable(true);
draw_set_alpha_test(true);
draw_set_alpha_test_ref_value(128);

draw_set_font(fntMain);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>d3d_end();
draw_set_alpha_test(false);

vertex_delete_buffer(global.floorVB);
vertex_format_delete(lvlVF);

for (var i=0; i&lt;ds_grid_width(mapVB); i++)
{
    for (var j=0; j&lt;ds_grid_height(mapVB); j++)
    {
        vertex_delete_buffer(mapVB[# i, j]);
    }
}
ds_grid_destroy(mapVB);

sprite_delete(global.mapTexSpr);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update game loop
stateTime++;
switch (state)
{
    case gSTATE.PRE:
        if (!stateInit)
        {
            stateInit = true;
            
            if (!audio_is_playing(musGameplay))
            {
                audio_play_sound(musGameplay, 0, true);
            }
            
            audio_sound_gain(musGameplay, 0, 0);
            audio_sound_gain(musGameplay, 1, room_speed);
        }
        
        state_set(gSTATE.MOVE);
        break;
        
    case gSTATE.PAUSED:
        if (!stateInit)
        {
            stateTime = 0;
            stateInit = true;
            
            audio_sound_gain(musGameplay, 0.25, room_speed);
        }
        
        if (keyboard_check_pressed(vk_escape))
        {
            state_set(gSTATE.MOVE);
        }
        else if (keyboard_check_pressed(ord("Q")))
        {
            room_goto(rm_menu);
        }
        break;
        
    case gSTATE.END:
        if (!stateInit)
        {
            stateTime = 0;
            stateInit = true;
            
            audio_sound_gain(musGameplay, 0, room_speed);
        }
        
        camRotH += 8;
        camZ += 2;
        
        if (stateTime &gt; room_speed * 2)
        {
            room_goto(rm_end);
        }
        break;
        
    case gSTATE.DIALOGUE:
        if (!stateInit)
        {
            stateInit = true;
            
            dialogueIn = true;
            dialogueTransitionCtr = 0;
            
            audio_sound_gain(musGameplay, 0.5, room_speed);
        }
        
        /// Check quit
        if (dialogueIn)
        {
            if (++dialogueTransitionCtr &gt; room_speed)
            {
                if (keyboard_check_pressed(ord("Z")))
                {
                    dialogueIn = false; // transition out
                    dialogueTransitionCtr = 0;
                    
                    // Play sound
                    var _s = audio_play_sound(sndImpactSmall, 0, 0);
                    audio_sound_pitch(_s, random_range(0.98, 1.02));
                }
            }
        }
        else
        {
            if (++dialogueTransitionCtr &gt; room_speed * 0.5)
            {
                state_set(gSTATE.MOVE);
            }
        }
        break;
        
    case gSTATE.ITEM_GET:
        if (!stateInit)
        {
            stateInit = true;
            
            itemIn = true;
            itemTransitionCtr = 0;
            
            audio_sound_gain(musGameplay, 0.5, room_speed);
        }
        
        /// Check quit
        if (itemIn)
        {
            if (++itemTransitionCtr &gt; room_speed)
            {
                if (keyboard_check_pressed(ord("Z")))
                {
                    itemIn = false; // transition out
                    itemTransitionCtr = 0;
                    
                    // Play sound
                    var _s = audio_play_sound(sndImpactSmall, 0, 0);
                    audio_sound_pitch(_s, random_range(0.98, 1.02));
                }
            }
        }
        else
        {
            if (++itemTransitionCtr &gt; room_speed * 0.5)
            {
                instance_destroy(itemTarget);
                itemTarget = noone;
                
                trashLeft--;
                if (trashLeft &gt; 0)
                {
                    state_set(gSTATE.MOVE);
                }
                else
                {
                    state_set(gSTATE.END);
                    
                    // Play sound
                    var _s = audio_play_sound(sndBeammeup, 0, 0);
                    audio_sound_pitch(_s, random_range(0.98, 1.02));
                }
            }
        }
        break;
        
    case gSTATE.MOVE:
        if (!stateInit)
        {
            stateInit = true;
            
            audio_sound_gain(musGameplay, 1.0, room_speed);
        }
        
        if (keyboard_check_pressed(vk_escape))
        {
            state_set(gSTATE.PAUSED);
        }
        
        // Update movement
        var _sprint = keyboard_check(vk_shift);
        var _move = keyboard_check(vk_up) - keyboard_check(vk_down);
        if (_move != 0)
        {
            var _macc = 0.15 + _sprint * 0.3;
            var _mmax = 1.5 + _sprint * 0.5;
            z3d_accelerate(_macc, _mmax, camFwdX * _move, camFwdY * _move, 0);
        }
        
        // Update camera
        var _lookh = keyboard_check(vk_right) - keyboard_check(vk_left);
        if (_lookh != 0)
        {
            camVelRot = clamp(camVelRot + _lookh * camLookVel, -camLookVelMax, camLookVelMax);
            camVelTilt = clamp(camVelTilt + _lookh * camLookVel * 0.1, -1, 1);
        }
        else
        {
            camVelRot *= 0.85;
            camVelTilt *= 0.85;
        }
        camRotH += camVelRot;
        
        camX += camVX;
        camY += camVY;
        camVX *= 0.9;
        camVY *= 0.9;
        
        camTilt += camVelTilt;
        camTilt *= 0.9; // gradually revert to neutral tilt position
        
        velFwd = dot_product(camFwdX, camFwdY, camVX, camVY);
        
        global.billboardFocusX = camX;
        global.billboardFocusY = camY;
        
        // Update player attributes
        playerHeight = playerHeightBase + noise2D(x, y) * 8;
        gridX = floor(camX / global.gridSize);
        gridY = floor(camY / global.gridSize);
        
        // Camera "collision" with level boundaries
        camX = median(camX, 8, gridW * global.gridSize - 8);
        camY = median(camY, 8, gridH * global.gridSize - 8);
        
        // Update camera bob
        var _bobStrength = clamp(velFwd, 0.0, 1.0); // multiply the result of sinewave by this to gradually reduce the bobbing effect when decelerating
        var _piRatio = pi / 32; // 1 bob per 32 units of movement
        camBobCounter += velFwd * _piRatio;
        
        // make camera bob &amp; add some subtle camera tilt
        var _osc = sin(camBobCounter);
        camVelTilt -= _osc * 0.1 * _bobStrength;
        camZ = playerHeight + abs(_osc) * camBobAmp * _bobStrength;
        
        // play footstep sound
        if (abs(_osc) &lt;= 0.2 &amp;&amp; !footstepPlayed)
        {
            footstepPlayed = true;
            
            var _s = audio_play_sound(sndWalk, 0, 0);
            audio_sound_pitch(_s, 1.0 + sign(_osc) * random_range(0.01, 0.1));
            audio_sound_gain(_s, 0.5 + sign(_osc) * random_range(0.01, 0.1), 0);
        }
        else if (abs(_osc) &gt;= 0.5)
        {
            footstepPlayed = false;
        }
        
        // Update NPC listening
        var _near = instance_fetch_range(camX, camY, oNPC, quipDist);
        if (_near != -1)
        {
            var _nearest = -1, _nearestDiff = 180, _nearestDist = quipDist;
            for (var i=0; i&lt;array_length_1d(_near); i++)
            {
                var _inst = _near[@ i];
                var _diff = abs(angle_difference(point_direction(camX, camY, _inst.x, _inst.y), -camRotH));
                var _dist = point_distance(camX, camY, _inst.x, _inst.y);
                
                if (_diff &lt; 90 &amp;&amp; (_diff &lt;= _nearestDiff || _dist &lt; _nearestDist))
                {
                    _nearest = _inst;
                    _nearestDiff = _diff;
                    _nearestDist = _dist;
                }
            }
            
            if (_nearest != -1)
            {
                quipTarget = _inst;
                quipTarget.isHighlighted = true;
                canQuip = true;
            }
            else
            {
                quipTarget = noone;
                canQuip = false;
            }
        }
        else
        {
            quipTarget = noone;
            canQuip = false;
        }
        
        if (quipTarget != noone)
        {
            if (canQuip &amp;&amp; keyboard_check_pressed(ord("Z")))
            {
                //showQuip = true;
                quipStr = quipTarget.quipCurrent;
                state_set(gSTATE.DIALOGUE);
                
                // Play sound
                var _s = audio_play_sound(sndImpact, 0, 0);
                audio_sound_pitch(_s, random_range(0.9, 1.1));
            }
        }
        
        // Update item collision
        var _nearItem = instance_nearest(camX, camY, oITEM);
        if (_nearItem != noone &amp;&amp; point_distance(camX, camY, _nearItem.x, _nearItem.y) &lt;= itemDist)
        {
            // Item get!
            itemTarget = _nearItem;
            itemName = itemTarget.name;
            itemDesc = itemTarget.desc;
            itemSprite = itemTarget.sprite_index;
            itemIdx = itemTarget.image_index;
            
            state_set(gSTATE.ITEM_GET);
            
            // Play sound
            var _s = audio_play_sound(sndItemGet, 0, 0);
            audio_sound_pitch(_s, random_range(0.95, 1.05));
        }
        
        // Optimize by deactivating instance
        instance_deactivate_all(true);
        instance_activate_region(camX - camFar, camY - camFar, camFar * 2, camFar * 2, true);
        break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Surface heartbeat
if (!surface_exists(gameSurf))
{
    gameSurf = surface_create(camResW, camResH);
    view_surface_id[0] = gameSurf;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State common behaviour
if (!audio_is_playing(musGameplay))
{
    audio_play_sound(musGameplay, 0, true);
}

switch (state)
{
    case gSTATE.DIALOGUE:
    case gSTATE.MOVE:
        // Update player hands
        if (canQuip)
        {
            hand2RotX = lerp(hand2RotX, -90, 0.05);
            
            hand1Z = lerp(hand1Z, -32, 0.05);
            hand2Z = lerp(hand2Z, 4, 0.05);
            
            hand2Side = lerp(hand2Side, -handMargin, 0.1);
            
            hand1Fwd = lerp(hand1Fwd, -32, 0.05);
            hand2Flip = true;
            
            if (keyboard_check(ord("Z")))
            {
                hand2Fwd = lerp(hand2Fwd, 24, 0.5);
            }
            else
            {
                hand2Fwd = lerp(hand2Fwd, 0, 0.3);
            }
        }
        else
        {
            var _bobStrength = clamp(velFwd, 0.0, 1.0);
            
            hand1RotX = lerp(hand1RotX, sin(camBobCounter * 0.5) * 4 * _bobStrength, 0.2);
            hand2RotX = lerp(hand2RotX, -hand1RotX, 0.2);
            
            hand1Z = lerp(hand1Z, sin(camBobCounter) * 6 * _bobStrength, 0.5);
            hand2Z = lerp(hand2Z, -hand1Z, 0.5);
            
            hand1Side = lerp(hand1Side, 0, 0.1);
            hand2Side = lerp(hand2Side, 0, 0.1);
            
            hand1Fwd = lerp(hand1Fwd, 0, 0.1);
            hand2Fwd = lerp(hand2Fwd, 0, 0.1);
            
            hand2Flip = false;
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>d3d_end();
draw_set_alpha_test(false);

vertex_delete_buffer(global.floorVB);
vertex_format_delete(lvlVF);

for (var i=0; i&lt;ds_grid_width(mapVB); i++)
{
    for (var j=0; j&lt;ds_grid_height(mapVB); j++)
    {
        vertex_delete_buffer(mapVB[# i, j]);
    }
}
ds_grid_destroy(mapVB);

sprite_delete(global.mapTexSpr);

/// reset audio
audio_stop_all();
if (!audio_is_playing(musAmbient))
{
    audio_play_sound(musAmbient, 0, true);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw surface
draw_surface_stretched(gameSurf, 0, 0, winSizeW, winSizeH);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// End shader
shader_reset();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set another camera &amp; Render hands
d3d_set_projection_ext(0, 0, 0, 1, 0, 0, 0, 0, 1, 80, winSizeW / winSizeH, camNear, 1024);

// render hands
d3d_set_hidden(false);
d3d_transform_stack_push();
d3d_transform_add_rotation_x(90 + hand1RotX);
d3d_transform_add_scaling(handSize, handSize, handSize);
d3d_transform_add_translation(handFwd + hand1Fwd, -handMargin + hand1Side, handZ + hand1Z);
vertex_submit(global.floorVB, pr_trianglelist, sprite_get_texture(sprHand, hand1Flip));
d3d_transform_stack_pop();


d3d_transform_stack_push();
d3d_transform_add_rotation_x(90 + hand2RotX);
d3d_transform_add_scaling(handSize, handSize, handSize);
d3d_transform_add_translation(handFwd + hand2Fwd, handMargin + hand2Side, handZ + hand2Z);
vertex_submit(global.floorVB, pr_trianglelist, sprite_get_texture(sprHand, hand2Flip));
d3d_transform_stack_pop();
d3d_set_hidden(true);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Enable alpha blending
draw_set_alpha_test(false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set camera
z3d_update_vectors();
d3d_set_projection_ext(camX, camY, camZ, camX + camFwdX, camY + camFwdY, camZ + camFwdZ, camUpX, camUpY, camUpZ, camFov, winSizeW / winSizeH, camNear, camFar);

view_xview[0] = camX;
view_yview[0] = camY;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Render background
var BGColour = make_colour_rgb(22, 22, 25);
draw_clear(BGColour);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set 3D shader &amp;&amp; Enable alpha blending
shader_set(shd_plz);
draw_set_alpha_test(true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State related GUI
var _cx = winSizeW &gt;&gt; 1, _cy = winSizeH &gt;&gt; 1;

switch (state)
{
    case gSTATE.PAUSED:
        // backdrop
        draw_rect(0, 0, _cx * 2, _cy * 2, c_black, 0.5);
        
        // text
        draw_set_halign(1);draw_set_valign(1);
        draw_text_transformed_colour(_cx, _cy, "PAUSED.", 3, 3, 0, c_white, c_white, c_white, c_white, 1.0);
        draw_text_transformed_colour(_cx, _cy + _cy * 0.5, "&lt;ESC&gt; : resume#&lt;Q&gt; : Quit to menu", 3, 3, 0, c_white, c_white, c_white, c_white, 1.0);
        draw_set_halign(0);draw_set_valign(0);
        break;

    case gSTATE.MOVE:
        draw_set_halign(1);draw_set_valign(0);
        draw_text_transformed_colour(_cx, 10, "X : " + string(gridX) + " | Y : " + string(gridY), 3, 3, 0, c_white, c_white, c_white, c_white, 1.0);
        if (canQuip)
        {
            draw_set_halign(1);draw_set_valign(2);
            ui_text(_cx, _cy + 64, "PRESS &lt;Z&gt;", 2, c_white, 1.0);
        }
        
        // draw trash counter
        draw_set_halign(1);draw_set_valign(0);
        ui_text(_cx, 64, "TRASH LEFT : " + string(trashLeft), 2, c_white, 1.0);
        
        // draw compass
        var _compasssizeL = 64;
        var _compasssizeS = 42;
        var _compassx = _cx + _cx * 0.85;
        var _compassy = 42 + _compasssizeL;
        
        var _dx = dcos(camRotH) * _compasssizeS;
        var _dy = dsin(camRotH) * _compasssizeS;
        
        draw_line_width_colour(_compassx, _compassy + 4, _compassx - _dx, _compassy - _dy + 4, 4, 0, 0);
        draw_line_width_colour(_compassx, _compassy + 4, _compassx + _dy, _compassy - _dx + 4, 4, 0, 0);
        draw_line_width_colour(_compassx, _compassy, _compassx - _dx, _compassy - _dy, 4, c_gray, c_gray);
        draw_line_width_colour(_compassx, _compassy, _compassx + _dy, _compassy - _dx, 4, c_white, c_white);
        
        _dx = dcos(camRotH) * _compasssizeL;
        _dy = dsin(camRotH) * _compasssizeL;
        
        draw_set_halign(1);draw_set_valign(0);
        ui_text(_compassx - _dx, _compassy - _dy, "y++", 1, c_white, 1.0);
        ui_text(_compassx + _dy, _compassy - _dx, "x++", 1, c_white, 1.0);
        ui_text(_compassx + _dx, _compassy + _dy, "y--", 1, c_white, 1.0);
        ui_text(_compassx - _dy, _compassy + _dx, "x--", 1, c_white, 1.0);
        ui_text(_compassx, _compassy - _compasssizeL, "^", 1, c_white, 1.0);
        draw_set_halign(0);draw_set_valign(0);
        break;
    
    case gSTATE.END:
        var _t = clamp(stateTime / (room_speed * 1.0), 0.0, 1.0);
        var _pt = power(_t, 3);
        
        draw_rect(0, 0, _cx * 2, _cy * 2, c_black, 1.0 * _pt);
        break;
        
    case gSTATE.ITEM_GET:
        var _t;
        if (itemIn)
        {
            _t = clamp(itemTransitionCtr / (room_speed * 0.5), 0.0, 1.0);
        }
        else
        {
            _t = 1.0 - clamp(itemTransitionCtr / (room_speed * 0.5), 0.0, 1.0);
        }
        var _pt = power(_t, 3);
        
        // backdrop
        draw_rect(0, 0, _cx * 2, _cy * 2, c_black, 0.5 * _pt);
        
        // letterbox
        var _letterboxHei = 40;
        var _letterboxDrawY = _pt * _letterboxHei;
        draw_rect(0, 0, _cx * 2, _letterboxDrawY, c_black, 1.0);
        draw_rect(0, _cy * 2 - _letterboxDrawY, _cx * 2, _letterboxDrawY, c_black, 1.0);
        
        // ITEM GET logo
        draw_set_halign(1);draw_set_valign(1);
        ui_text(_cx, _cy * 0.25, "GOT JUNK.", 5, c_white, 1.0);
        ui_text(_cx, _cy * 0.25 + 80, '"' + itemName + '"', 3, c_white, 1.0);
        draw_set_halign(0);draw_set_valign(0);
        
        var _iconmargin = 80;
        var _rotx = dcos(stateTime * 10.0) * 24;
        var _roty = dsin(stateTime * 10.0) * 16;
        draw_sprite_ext(sprFaceHellYes, 0, _cx - _iconmargin - 128, _cy, 5, 5, 0, c_white, 1.0);
        draw_sprite_ext(sprFaceHellYes, 1, _cx - _iconmargin + _rotx, _cy + _roty, 5, 5, 0, c_white, 1.0);
        draw_sprite_ext(itemSprite, itemIdx, _cx + _iconmargin, _cy, 10, 10, dsin(stateTime * 5) * 4, c_white, 1.0);
        
        // text box
        var _tbsize = _cx * 0.9;
        var _tbheight = string_height_ext(itemDesc, 14, _tbsize - 24) * 2 + 24;
        var _tby = lerp(_cy * 2, _cy * 2 - _tbheight - 150, _pt);
        
        draw_rect(_cx - _tbsize + 16, _tby + 16, _tbsize * 2, _tbheight, c_black, 1.0);
        draw_rect(_cx - _tbsize, _tby, _tbsize * 2, _tbheight, c_white, 1.0);
        draw_rect(_cx - _tbsize + 4, _tby + 4, _tbsize * 2 - 8, _tbheight - 8, make_colour_rgb(22, 22, 25), 1.0);
        
        // text
        draw_set_halign(0);draw_set_valign(0);
        var _showstr = string_copy(itemDesc, 1, string_length(itemDesc) * _pt);
        ui_text_wid(_cx - _tbsize + 12, _tby + 8, _showstr, 2, c_white, 1.0, 14, _tbsize - 24);
        
        draw_set_halign(1); draw_set_valign(0);
        
        if (itemTransitionCtr &gt;= room_speed)
        {
            ui_text(_cx, _tby + _tbheight + 12, "Nice. PRESS &lt;Z&gt; to continue.", 2, c_white, 1.0);
        }
        
        draw_set_halign(0);draw_set_valign(0);
        break;
    
    case gSTATE.DIALOGUE:
        var _t;
        if (dialogueIn)
        {
            _t = clamp(dialogueTransitionCtr / (room_speed * 0.5), 0.0, 1.0);
        }
        else
        {
            _t = 1.0 - clamp(dialogueTransitionCtr / (room_speed * 0.5), 0.0, 1.0);
        }
        var _pt = power(_t, 3);
        
        // backdrop
        draw_rect(0, 0, _cx * 2, _cy * 2, c_black, 0.3 * _pt);
        
        // letterbox
        var _letterboxHei = 40;
        var _letterboxDrawY = _pt * _letterboxHei;
        draw_rect(0, 0, _cx * 2, _letterboxDrawY, c_black, 1.0);
        draw_rect(0, _cy * 2 - _letterboxDrawY, _cx * 2, _letterboxDrawY, c_black, 1.0);
        
        // text box
        var _tbsize = _cx * 0.9;
        var _tbheight = 200;
        var _tby = lerp(_cy * 2, _cy * 2 - _tbheight - 128, _pt);
        
        draw_rect(_cx - _tbsize + 16, _tby + 16, _tbsize * 2, _tbheight, c_black, 1.0);
        draw_rect(_cx - _tbsize, _tby, _tbsize * 2, _tbheight, c_white, 1.0);
        draw_rect(_cx - _tbsize + 4, _tby + 4, _tbsize * 2 - 8, _tbheight - 8, make_colour_rgb(22, 22, 25), 1.0);
        
        // text
        draw_set_halign(0);draw_set_valign(0);
        var _showstr = '"' + string_copy(quipStr, 1, string_length(quipStr) * _pt) + '"';
        ui_text_wid(_cx - _tbsize + 12, _tby + 8, _showstr, 2, c_white, 1.0, 14, _tbsize - 24);
        
        draw_set_halign(0); draw_set_valign(2);
        if (dialogueTransitionCtr &gt;= room_speed)
        {
            ui_text(_cx, _tby + _tbheight - 14, "Nice. PRESS &lt;Z&gt; to continue.", 2, c_white, 1.0);
        }
        draw_set_halign(0);draw_set_valign(0);
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Render grid of floor
var _renderdist = 6;

for (var i=gridX - _renderdist; i&lt;=gridX + _renderdist; i++)
{
    for (var j=gridY - _renderdist; j&lt;=gridY + _renderdist; j++)
    {
        if (i &lt; 0 || i &gt;= ds_grid_width(mapVB) ||
            j &lt; 0 || j &gt;= ds_grid_height(mapVB))
            continue;
        
        vertex_submit(mapVB[# i, j], pr_trianglelist, sprite_get_texture(global.mapTexSpr, 0));
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
